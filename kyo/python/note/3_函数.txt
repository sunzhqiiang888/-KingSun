为何使用函数
    最大化的代码重用和最小化代码冗余
    流程的分解

-------------------------------------------------------------------------------
函数的定义
    def 函数名([参数, ...]):
        函数体内容
        [return [函数返回值]]

函数的调用
    函数名([参数, ...])

-------------------------------------------------------------------------------
函数的参数传递语法
    Python的函数的参数可以没有也可以有多个
    函数定义位置的参数为形参，函数调用位置的参数为实参

    默认情况下:
        实参个数必须与形参个数一致
        实参类型必须与形参类型一致(主要体现在形参使用时)
        形参是复制实参数据
            Python中变量赋值都为引用赋值, 本应该在函数内部修改实参变量的值
            但Python中部分数据类型的数据不能修改(数字 字符串 元组)
            故只有可变类型数据才能在函数内部修改(列表 字典 集合)

    函数参数传递类型
        位置参数传递
            实参第一个与形参第一个对应传递
            实参第二个与形参第二个对应传递
            ...
            以此类推

        关键词参数传递
            实参使用形参名赋值传递，这样与位置无关, 但必须保证参数名对应

        位置参数和关键词参数传递可以混用, 但只要出现关键词参数后就不能再使用位置参数

        例:
            def test(a, b, c):
                print(a, b, c)

            位置参数传递:
                test(1, 2, 3)
                    a=1, b=2, c=3

            关键词参数传递
                test(c=15, a="hello", b="BBB")
                    a="hello", b="BBB", c=15

    参数默认值
        形参设置默认值，这样如果实参对应没有传递则使用默认值运算
        但参数默认值必须从右向左连续设置，中间不能断，否则报错

        例:
            def test(a=34):
                print(a)

            test()      不传递参数a为34
            test(10)    传递参数a为10

    可变长度参数(可变参)
        参数默认值已经实现实参个数可与形参个数不一致, 但参数个数最大也是形参定义个数
        如果传给函数的参数数量无法确定，可以使用可变长度参数(*args, **kargs)

        *args结构接受所有额外的位置参数，存于args元组对象中来访问使用
        **kargs结构接受所有额外的关键词参数，存于kargs字典对象中来访问使用

        因此想要实现可变长度参数的函数，函数原型必须定义*args和**kargs两个接受参数的结构

        强制某个参数按关键词传递: def func(*arg, name)  #name必须按关键词参数传递
        强制所有参数按关键词参数传递: def func(*, name)

        例:
            def test(a, b, *args, **kargs):
                print(a, b, args, kargs)

            test(11, 22)
            test(11, 'hello', 1, 2, 3, 4, 5, 6)
            test(11, 'hello', 1, 2, 3, 4, 5, 6, name='tom', age=13)

    函数调用参数展开
        将元组或列表按位置参数传递展开
            序列第一个元素为函数第一个参数，第二个元素为函数第二个参数, 以此类推
            例:
                def test(a, b, c, d):
                    print(a, b, c, d)

                args = (1, 2, 3, 4)
                test(*args)

        将字典将关键词参数传递展开
            字典的key为参数名，value为参数值
            例:
                def test(name, age):
                    print(name, age)

                kargs = {'name': 'tom', 'age': 15}
                test(**kargs)

-------------------------------------------------------------------------------
函数的返回值
    使用return关键词返回函数的返回值, return后可以书写变量、表达式和函数调用等
    如果不使用return指定返回值或没有书写return，默认函数也会返回一个None对象
    函数只能返回一个值，如果想返回多个值，可打包成元组/列表/字典等返回

-------------------------------------------------------------------------------
嵌套函数(内部函数)
    在函数内定义的函数为嵌套函数, 可以定义多级嵌套函数
    嵌套函数默认对外部不可见，即不能直接调用，可通过函数返回来等其它方法来调用
    嵌套函数内如果想改变上层函数变量时需要使用nonlocal声明
    例:
        def funcA():
            a = 12
            def funcB():
                nonlocal a
                a += 1
                print('funcB a = ', a)

            funcB()

-------------------------------------------------------------------------------
变量作用域
    作用域就是变量定义和查找的位置, 它决定变量起作用的范围
    在Python代码中定义变量时，Python会在名字空间(命名空间)里创建、更改或查找等
    所谓的作用域指的就是名字空间，一个变量的作用域由它赋值操作的位置决定
    Python的变量作用域:
        内置命名空间
            内置命名空间存储Python虚拟机提供功能名字, 如open range, list等
            builtins内置模块, 内置命名空间有哪些名字可查看此模块所属命名即可

        全局(模块)命名空间
            在python文件中直接定义的变量(顶层定义的变量)
            或者在def语句中使用global声明的变量

        外围函数命名空间
            任何一个外围函数的本地作用域，从里到外

        本地命名空间
            函数内部通过任何赋值方法定义的变量, global/nonlocal声明的除外

    变量的解析: LEGB原则
        当函数中使用未谁的变量名时，Python会按顺序搜索4个作用域
            本地作用域(L) -> 上层def或lambda的本地作用域(E) -> 全局作用域(G) ->  内置作用域(B)

-------------------------------------------------------------------------------
函数递归调用
    函数递归调用: 在函数内部调用函数自身
    函数递归调用必须设置退出条件，否则为死递归无意义
    函数递归调用为数据结构栈(先进后出)的应用
    Python递归深度是有限制的，默认为1000次, 可以通过sys.setrecursionlimit()来修改

-------------------------------------------------------------------------------
回调函数
    在Python当中一切皆为对象，函数也一样是对象, 即函数名也可以像变量一样的操作
    有意义函数名操作: 函数名可以作为函数参数传递，也可以作为返回值返回
    回调函数: 当函数作为函数参数传递时
    回调函数使函数实现多态(程序运行时才确定要执行什么)
    回调函数大大的增强了函数的可扩展性

    可以通过callable来判断参数是否为可执行代码(回调函数)

-------------------------------------------------------------------------------
闭包(工厂函数)
    闭包是根据不同的配置信息得到不同的结果
    闭包的条件:
        外部函数内必须定义一个嵌套函数
        嵌套函数必须引用了外部函数的变量
        外部函数必须返回嵌套函数

    闭包的作用: 创建函数专属的全局变量(私有变量)

    例:
        def closure():
            x = 0
            def subClosure():
                nonlocal x
                x += 1
                return x
            return subClosure

        c1 = closure()      #创建闭包，创建c1函数的私有变量(专属全局变量)
        c2 = closure()      #创建闭包，创建c2函数的私有变量(专属全局变量)

        print(c1())     # 返回1
        print(c1())     # 返回2
        print(c2())     # 返回1
        print(c2())     # 返回2

    与C语言的静态变量的区别:
        创建闭包时将外部函数的变量与闭包函数相关联, 实现闭包函数专属的全局变量
        静态变量则是函数的专属全局变量, 只要是此函数调用就会影响此变量

    闭包滥用会导致内存泄漏

----------t---------------------------------------------------------------------
装饰器
    代码运行期间动态增加功能的方式称之为装饰器(Decorator)
    Decorator其实就是一个闭包, 把一个函数作为参数返回一个替代版函数
    装饰器函数接受必须再次嵌套函数:
        装饰器函数接受装饰器的参数
        嵌套函数传递接受被装饰函数

    比如: 在一个函数调用前后自动打印日志,不修改原函数的定义
        def decro(func):
            print("进入装饰器函数")
            def inner():
                print("原函数前面要执行的代码块")
                func()
                print("原函数后面要执行的代码块")
            return inner()

        @decro
        def test():
            print("进入原函数要执行的代码块")

        test()      ==> decro(test)()

-------------------------------------------------------------------------------
匿名函数的用法(lambda)
    匿名函数是为了简化函数定义的书写形式，使代码更简洁
    python使用lambda关键词来定义匿名函数

    lambda表达式语法:
        lambda 函数参数列表: 匿名函数返回表达式

    例1:
        f = lambda x, y: x + y
        print(f(1, 2))      # 3

    例2:
        def test(a, b, op=lambda a, b: a + b):
            return op(a, b)

        test(100, 200)
        test(100, 200, lambda a, b: a + b)

-------------------------------------------------------------------------------
函数式编程
    map 对序列每个元素进行操作，最终返回操作后的新序列
        map函数原型: map(操作函数, 操作的序列, ...)
            操作函数的参数个数取决后面传入序列参数的个数

        例: 对序列每个元素加100
            map(lambda a: a + 100, [11, 22, 33])    # [111, 122, 133]

        例: 对两个序列每个元素相加
            map(lambda a, b: a + b, [11, 22, 33], [1, 2, 3]) # [12, 24, 36]

    filter 对序列中元素进行筛选，最终返回符合条件的序列
        filter函数原型: filter(过滤函数, 操作的序列)
            过滤函数只传入一个参数，返回布尔型

        例: 找出序列大于30的数
            filter(lambda n: n > 30, [66, 78, 12, 33, 16, 5]) #[66, 78, 33]

    reduce 对序列内所有元素进行累计操作
        python3将reduce放入functools模块中, 必须先导入此模块才能使用
        reduce函数原型: reduce(操作函数, 操作序列, 起始位置)
            操作函数接受两个参数，累计操作的两个元素
            起始位置是可选项，默认从0开始

        例: 对序列求和
            reduce(lambda n1, n2: n1 + n2, [1, 2, 3, 4, 5])  # 15

-------------------------------------------------------------------------------
作业:
    斐波那契数列实现 (循环和递归)
    输出十进制转八进制的数
    猴子吃桃，每天吃前一天的一半加1个桃子，第5天吃完剩一个，求还没吃之前的总数
    判断一字符串中括号是否匹配
    迷宫求解
    (5 _ 3) _ 2 = 4 填写符号使表达式成立(+ - * / % ^(幂))

    利用map()函数把用户输入的不规范的英文名字，变为首字母大写其他小写的规范名字
        输入：['adam', 'LISA', 'barT']
        输出：['Adam', 'Lisa', 'Bart']

    请编写一个prod()函数，可以接受一个list并利用reduce()求积
    利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456

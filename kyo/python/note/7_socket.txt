ISO/OSI网络分层参考模型 (由下向上)
    物理层          规定物理线路等为上层的传输提供的物理介质，本层是通信端点的硬件接口，本层数据传输单位为比特(b). 网卡、网线等属于本层
    数据链路层      在物理介质基础上提供可靠的数据传输，提供物理地址寻址、把数据换成帧、数据检测重发、流量控制等，本层数据单位为帧，以太网交换机，网桥等属于本层
    网络层          负责将各个子网之间的数据进行路由选择，将数据从一个主机传送到另一主机，本层数据的单位为数据包， IP协议，路由器、网关等属于本层
    传输层          负责将上层的数据处理为分段的数据，提供可靠或不可靠的传输，保证会话层的数据信息传送到另一个会话层或应用层，本层数据单位为数据段，TCP协议 UDP协议等属于本层
    会话层          管理主机之间的会话建立终止等 TCP/UDP也属于本层
    表示层          对网络传输数据进行变换，包括数据的压缩加密格式转换， ASCII、JPEG、MPEG等标准属于本层
    应用层          为应用程序提供访问网络服务的接口，FTP、HTTP、SNMP、P2P等协议属于本层

    应用程序发送数据要经过应用层->表示层->会话层->传输层->网络层->数据链路层 每层都会对用户数据进行封装，这个过程叫封包过程，然后给物理层传出去
    接收数据主机从物理层得到数据后，再经过数据链路层->网络层->传输层->会话层->表示层->应用层对其数据进行解封，再给应用程序

    OSI只是标准，规定哪一层做哪些工作，没有一个实际使用七层的网络协议栈, 因为实现起来太庞大太复杂，所以基本上不用此标准，实际实现中，TCP/IP协议栈获得了更为广泛的应用

-------------------------------------------------------------------------------
TCP/IP协议栈参考模型 (由下向上)
    数据链路层      把OSI的物理层数据链路层合并
    网络层          和OSI网络层功能一样，是TCP/IP协议的核心，也称IP层
    传输层          TCP/UDP协议
    应用层          TFTP、NFS、HTTP、FTP等

    以太网(属于数据链路层的协议)

-------------------------------------------------------------------------------
IP协议
    IP协议是TCP/IP协议中最重要的协议，为TCP、UDP等协议提供传输通路，使不同的子网之间能传输数据, IP协议主要作用: 数据传送 寻址 路由选择 数据报文分段

IP地址分类
    IP地址由类别、网络地址、主机地址组成
        类别区分IP地址的类型
        网络地址表示主机所在的网络
        主机地址表示主机在网络的标识
    IP地址的分类
        A类地址
            网络地址占1个字节，最高位为0，其它为主机地址, 开始范围0到127
            应用大量主机的网络，1/3已经被用于主干网络和大公司

        B类地址
            网络地址占2个字节，最高2位为10，其它为主机地址, 开始范围128到191 应用如区域网

        C类地址
            最常见的地址，网络地址占3个字节，最高3位为110，其它为主机地址, 开始范围192到233，应用如校园网

        D类地址
            最高4位为1110，此类地址用于组播，例如路由器修改、视频会议等应用系统, 开始范围224到239
        E类地址， 前4位为1111，为保留地址，目前没有用 开始范围240到255

    特殊的地址：
        主机地址所有位为0的IP地址，不能用，仅用于表示某个网络的网络地址
        主机地址所有位为1的IP地址，不能用，仅表示广播地址，向此地址发送数据，全网络的主机都接收
        IP地址所有位为1的地址, 为有限广播地址
        IP地址所有位为0的地址，表示主机本身
        127开头为特殊的回环接口，常用于本地软件测试，如果ping不通说明操作系统不支持TCP/IP协议
        私有地址，以10、172、192开头的地址，不同的局域网内多次使用

    子网掩码
        利用32位字段的数值屏蔽原来网络地址的划分情况，从而获得一个范围小可以实际使用的网络
        子网掩码的好处：便于网络设备尽快寻址，区分本网段和非本网段地址，还可以划分子网

TCP(传输控制协议)
    在IP协议基础上，增加确认重发，复用/解复用等机制，提供一种可靠、面向连接的协议

    TCP建立连接的三次握手
        建立一条TCP连接需要进行三次通信过程
        1. 主机A发送SYN到主机B告诉B想要连接的主机端口，以及初始序列号
        2. 主机B应答，发送SYN和ACK，初始化序列号，再把A发送过来的序列号加1添加到确认序列号
        3. 主机A再将主机B发送的序列号加1作为确认序列号ACK并且在数据段放写序列号加1发给主机B

        SYN洪水攻击(SYN Flooding)
            建立连接第二次握手后，客户端故意不发送第三次握手ACK，这样服务器在无限等待，等待会占用服务器资源，这种客户端到达一点数量时，服务器就会因资源不够而停止响应，这是一种典型的DDOS攻击

    TCP发送数据，接收端会返回ACK, 如果没有收到ACK，在一定时间内会重发，重发一定次数后如果还没有收到ACK则断线

    TCP释放连接的四次握手
        1. 主机A发送FIN和初始化序列号发送给主机B
        2. 主机B把主机A发送过来的序列号加1作为确认号发送ACK给主机A
        3. 主机B发送FIN和实始化序列号发送给主机A
        4. 主机A把主机B发送过来的序列号加1作为确认号发送ACK给主机B

端口
    为了区分不同应用程序数据和状态，引入端口概念
    端口是一个16位的无符号整型，是操作系统标识网络应用程序的一种方法
    小于1024的端口为保留端口，由系统的标注服务程序使用，1024以上端口用户程序可以使用
    例如：
        ssh 基于TCP 22端口， ftp 基于TCP 20端口
        vim /etc/services   服务端口绑定情况

-------------------------------------------------------------------------------
网络工具使用
    ping
        检测本机与被测主机之机网络是否相通
        检测本机与被测主机之间网络的网速
        测试域名解析(DNS)是否有效

    ifconfig
        查看与设置网卡信息
        ifconifg eth0   查看eth0网卡信息
        ifconfig eth0 192.168.1.23 netmask 255.255.255  修改网卡IP地址与子网掩码
        ifconifg eth0 hw ether 00:11:22:33:44:55        修改网卡的MAC地址
        ifconfig eth0 up/down    激活/关闭eth0网卡

    route                               路由表设定和查看
        -n                              不把IP地址转为域名输出，会快很多
        route add default gw 2.2.2.1    添加网关
        route del default gw 2.2.2.1    删除网关
        route add -net 2.2.2.1  netmask 255.255.255.0 dev eth0  添加一个路由条目
        route del -net 2.2.2.1  netmask 255.255.255.0 删除一个路由条目

    netstat                             显示网络连接情况
        netstat  -r -n                  显示路由表
        netstat  -i -e                  显示网卡信息
        netstat  -a                     查看所有类型的连接信息
        netstat  -nt                    查看所有的tcp的连接信息(-t),-n不把IP转换成域名
        netstat  -ntl                   只查看tcp连接并且是处于listen状态
        netstat  -utl                   只查看udp连接并且是处于listen状态
        netstat  -ntlp                  显示打开的连接对应的程序，-p 显示程序的路径

    tcpdump                             抓包工具
        tcpdump  arp                    捕捉arp协议的数据包
        tcpdump  tcp                    捕捉tcp协议的所有数据包
        tcpdump  udp                    捕捉udp协议的所有数据包
        tcpdump  tcp port 22            捕捉tcp协议并且是端口22的数据包
        tcpdump  tcp port 22 -vv        同上并且把数据包的详细信息都记录下来
        tcpdump  tcp src port 22        只记录源端口是22的数据包
        tcpdump  dst 2.2.2.10           只记录目的IP是2.2.2.10的数据包
        tcpdump  tcp dst port 80        只记录访问本机80端口的数据包
        tcpdump  tcp dst port 80 -vv -w /tmp/test/http.cap   把记录保存到文件中

    wireshark                           图形抓包工具
        apt install wireshark -y        安装wireshark

-------------------------------------------------------------------------------
socket模块
    套接字是通信端点的抽象, 类似应用程序使用文件描述符一样访问文件
    访问套接字就要用套接字描述符, 操作方法类似文件描述符的操作

    创建套接字
        sd = socket.socket(family=AF_INET, type=SOCK_STREAM, proto=0)
        成功返回套接字对象
        family          指定网络通信域，AF_INET为IPv4通信域
        type            指定套接字通信类型
            SOCK_STREAM 字节流套接字,TCP(传输控制协议)
            SOCK_DGRAM  数据报套接字,UDP(用户数据报文协议)
            SOCK_RAW    原始网络协议访问
        protocol        用于指定某个协议的特定类型, 默认指定通信类型的默认协议

    绑定地址端口
        sd.bind((address, port))
            address         要绑定本地的哪个IP地址
            port            要绑定哪个端口

    设置的获取套接字选项
        sd.setsockopt(level, optname, value)
        sd.getsockopt(level, optname)

        例1: 端口复用
            sd.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)

        例2: 开启广播支持
            sd.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)

    设置套接字是否阻塞
        sd.setblocking(True/False)

    设置套接字阻塞超时时间
        sd.settimeout(timeout)
            timeout为超时时间(单位为秒), 浮点数类型

    监听本地端口
        sd.listen([backlog])
            backlog         表示可服务连接请求数量, 实际值由系统决定

    接受网络请求并返回新套接字
        sd.accept()
            执行成功返回新套接字对象和连接信息对象的元组
            调用此函数会查看连接队列是否有连接
            如没有阻塞等待，直到有连接返回表示连接的新套接字描述符
            成功后对返回的表示客户连接的套接字描述符读则为接受客户端发送的数据
            写则给客户端发送数据

    开启一个套接字连接
        sd.connect(address)
            连接指定服务器(TCP三次握手请求)
            address     指定服务器IP和端口号的元组
            连接失败会抛出异常

        sd.connect_ex(address)
            与sd.connect功能一样, 区别在于连接失败是返回错误码

    切断套接字的连接
        sd.shutdown(flags)
            flags参数的取值:
                0 SHUT_RD     表示切断读
                1 SHUT_WR     表示切断写
                2 SHUT_RDWR   表示切断读写和close功能一样

    关闭套接字
        sd.close()

    数据传输
        sd.send(data[, flags])
            将data内容写入套接字，即发送数据, 返回发送数据的字节数
            用于TCP协议发送数据

            flags的取值:
                MSG_DONTROUTE       勿将数据路由出本地网络
                MSG_DONTWAIT        允许非阻塞操作
                MSG_EOR             协议支持为记录结束
                MSG_OOB             协议支持发送带外数据(高优先级的数据传输)

        sd.sendto(data[, flags], address)
            比send功能多一个可以指定目标发送数据
            用于UDP协议发送数据


        sd.recv(buffersize[, flags])
            指定大小读取套接字接受的数据, 用于TCP协议接受数据,
            返回接受到的数据

        sd.recvfrom(buffersize[, flags])
            比recv多一个功能返回数据和发送端信息的元组
            多用于UDP协议接收数据

        sendmsg/recvmsg     只针对套接字描述符有用，更高级收发操作(支持多缓冲区)

        如果其中一端socket关闭，另一端发送数据，会产生SIGPIPE信号


    获取套接字绑定本地的端口与IP
        sd.getsockname()

    获取套接字通信的端口与IP(获取客户端IP与端口)
        sd.getpeername()

-------------------------------------------------------------------------------
UDP传输协议的使用
    服务端:
        创建UDP套接字对象
            sd = socket.socket(AF_INET, SOCK_DGRAM)

        给UDP服务端绑定端口号和IP
            sd.bind(('127.0.0.1', 9000))

        阻塞等待客户端发送的数据
            cmd, addr = sd.recvfrom(1024)

        给客户端发送数据
            sd.sendto("hello".encode(), addr)

        关闭UDP套接字对象
            sd.close()

    客户端:
        创建UDP套接字对象
            sd = socket.socket(AF_INET, SOCK_DGRAM)

        给服务器发送数据
            sd.sendto("hello".encode(), addr)

        接受服务器数据
            cmd, addr = sd.recvfrom(1024)

        关闭UDP套接字
            sd.close()

-------------------------------------------------------------------------------
TCP传输协议的使用
    服务端:
        创建TCP套接字对象
            sd = socket.socket(AF_INET, SOCK_STREAM)

        给服务器绑定端口和IP
            sd.bind(('127.0.0.1', 9000))

        开启套接字对象支持端口复用
            sd.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)

        设置TCP套接字监听队列
            sd.listen(5)

        等待客户端连接返回新套接字通信
            conn, addr = sd.accept()

        接受客户端数据或给客户端发送数据
            conn.recv(1024)
            conn.send(data)

        关闭客户端套接字
            conn.close()

        关闭TCP套接字
            sd.close()

    客户端:
        创建TCP套接字对象
            sd = socket.socket(AF_INET, SOCK_STREAM)

        连接TCP服务器
            sd.connect_ex(('127.0.0.1', 9000))   会返回错误码，不抛异常
                或
            sd.connect()    会抛异常

        发送或接受数据
            sd.recv(1024)
            sd.send("hello".encode())

        关闭套接字对象
            sd.close()

-------------------------------------------------------------------------------
网络异常处理
    UDP服务端支持多人同时连接(解决多人通讯不会混乱)
        来一个连接创建一个线程或进程并且创建新套接字与此客户端通讯

    读写不同步
        数据丢失
        缓冲区溢出(发的太快 收的太慢)

        解决：
            发包验证，发一个包要等待一回应包再发第二包
            建立重发机制
                等待回应包只等一段时间再重发 重发几次还没有收到就断开
                I/0复用机制(poll/select)

    收发数据混乱
        自己创建协议 定义每种包的类型，在数据前加包的类型再发送

    数据安全
        在收发数据前增加检验机制(检验和)

    数据大小不能超过1500个字节(包含所有协议头)
        eth(14) + ip(20) + udp(8)

    推荐协议数据包的定义字段包含如下:
            magic       协议标识
            type        数据包类型
            sum         数据包的检验和
            data        数据包实际数据

-------------------------------------------------------------------------------
练习：
    1. 完善聊天程序

作业：
    1. 实现scp命令(文件下载上传功能，支持断点续传)

    2. 实现ssh程序， 服务器 + 客户端
        a. 支持用户登录，密码验证
        b. 命令解析 客户端发命令->服务器接收解析执行把结果返回客户端->客户端把结果显示出来，再次接收命令
        c. 退出命令

Python变量存储原理(引用赋值/引用传递):
    任何的值都是占内存空间, 并且占的空间大小不一样
    Python的变量只是保存内存地址, 所有赋值操作都是内存地址赋值

    a = 13
        13  -> 0x333
    a(0x333)
    b = "hello"
        "hello" -> 0x888
    b(0x888)

    a = b
        只是将b变量保存的地址赋给a
        a(0x888)

-------------------------------------------------------------------------------
基本语法
    Python文件由多条逻辑行(Python按逻辑行解析代码)构成
    物理行表示字符序列有行尾结束标识符(人眼看到的行)

    一般情况一条逻辑行对应一条物理行
    逻辑行字符过长, 有可能将一条逻辑行变成多条物理行
        Python提供了两个拆行语法:
            \
            () [] {}        推荐使用小括号来连接

        逻辑行会很长的情况:
            函数的定义和调用的参数过长
            字符串过长
            逻辑表达式

    多条逻辑行写在一条物理行当中, 使用分号来隔开(不推荐使用)

    三目运算符 一般处理条件赋值
        变量名 = 条件成立的值 if 条件表达式 else 条件不成立的值

函数
    函数的定义
    函数的参数
        形参和实参
            形参是复制实参变量的值
            实参传递为引用传递, 但由于Python类型的限制(部分类型数据是不能修改)
        位置参数
        关键字参数
        参数默认值
        可变参
    内部函数/嵌套函数
        nonlocal        声明变量是在外部函数域定义
        global          声明变量是在全局域定义
    变量作用域(LEGB)
        L   函数内
        E   外部函数
        G   全局
        B   Python内置
    函数的返回值
        Python的函数绝对会有返回值
        使用return关键词进行返回值, 不写return也会返回None
        实现函数式编程, 函数的返回值作为另一个函数的参数
    函数的调用(递归)
        Python3对递归有限制(默认为1000次左右):
            修改python3对递归的限制
                import sys
                sys.setrecursionlimit(1000)

        猴子吃桃, 每天吃前一天的一半加1个, 第5天吃完还剩一个, 问没吃之前有多少个桃子
            def test(day):
                if day == 0:
                    return 1
                return (test(day) + 1) * 2

        判断字符串中括号匹配
            "(hello)"
            "<htm{[hello}]l>"

        浮点数转字符串

    回调函数/匿名函数(lambda)
        callable        判断变量是否为可执行对象

        填写符号使下面表达式成立(+ - * / % ^(幂)):
            (5 _ 3) _ 2 = 4

            (5 + 3) / 2 = 4
            (5 - 3) * 2 = 4
            (5 - 3) + 2 = 4
            (5 - 3) ^ 2 = 4
            (5 % 3) + 2 = 4
            (5 % 3) * 2 = 4
            (5 % 3) ^ 2 = 4

        编写函数将用户输入不规范的英文名字进行格式化(首字母大写, 其它小写)

    闭包
        内部函数使用了外部函数的变量并且作为返回值返回
        闭包实现一个函数专属的全局变量

    装饰器
        代码运行期间动态增加功能的方式为装饰器

    迭代器
        可迭代对象
            判断对象是否为可迭代对象:
                import Collections.Iterable
                isinstance(对象, Collections.Iterable)

        for ... in 语句可以遍历可迭代对象

        iter        将可迭代对象转成迭代器对象
        next        返回将迭代器内下一个数据,  如果没有抛出StopIteration异常

    生成器
        生成器是特殊的迭代器, 生成器用于节省内存空间
        在函数内部出现yield关键词, 此函数为生成器函数对象

